<!DOCTYPE html>
<html>
  <head>
    <title>Global spectral clustering in dynamic networks</title>
    <meta charset="utf-8">
    <meta name="author" content="presenter: Shamindra Shrotriya" />
    <meta name="date" content="2018-10-01" />
    <link href="libs/remark-css/default.css" rel="stylesheet" />
    <link href="libs/remark-css/default-fonts.css" rel="stylesheet" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Global spectral clustering in dynamic networks
## Fuchen Liu, David Choi, Lu Xie, Kathryn Roeder
### presenter: Shamindra Shrotriya
### 2018-10-01

---




# Networks are central to community detection
--

Networks or graphs are used to display **connections** within a complex system 

--

The **vertices** in a network often reveal clusters with many edges joining vertices of the same cluster

--

Such clusters or **communities** could arise from functionality of distinct components of the network

---

# Motivation for Dynamic Networks

--

Statistical theory has mostly focused on **static networks** observed as a single snapshot in time 

--

In reality networks are generally **dynamic** in a temporal sense

--

It is of substantial interest to discover the communities within each network model their connectivities

--

Moreover having effective methods of **visualizing changing community structure** is equally important

---
# PisCES : A new algorithm for dynamic community detection

--

Paper proposes the persistent communities by eigenvector smoothing (PisCES) algorithm for detecting time-varying community structure 

--

Applied to changing gene expression is measured during a broad range of developmental periods in rhesus monkey brains. 

--

The analysis suggests the existence of **change points** as well as periods of persistent community structure

--

Fundamentally the method is driven by extending spectral graph theory algorithms with temporal changes

---

## Spectral Methods for Static Networks are used for community detection

--

Spectral clustering is a popular class of methods for finding communities in a static network

--

Interactions are represented by is a symmetric `\(n \times n\)` adjacency matrix `\(A\)` and a fixed number of communities `\(K\)`

--

Method computes the degree-normalized (or “Laplacianized”) adjacency matrix `\(L\)`

`$$L = D^{-1/2}AD^{-1/2} \quad \text { where } \quad D = \operatorname{diag}(\text{ degree })$$`

--

Eigenvectors corresponding to its `\(K\)` largest eigenvalues of `\(L\)` in absolute value are selected

--

Returns the clusters found by K-means clustering on the eigenvectors of `\(L\)` 

---

# Spectral Methods for Dynamic Networks smooth static networks over time

--
Let `\(A_1 , \ldots , A_T\)` denote a time series of symmetric adjacency matrices for `\(t = 1, \ldots , T\)`  

--

let `\(L_t\)` denote the Laplacianized version of `\(A_t\)`  and `\(K\)` be fixed 

--

Let `\(V_t \in \mathbb{R}^{n \times K}\)` denote the matrix whose columns are the K leading eigenvectors of `\(L_t\)` . Let `\(U_t = Vt\)` the projection matrix onto the column space of Vt.
        
`$$\min_{ \overline{U}_{1} , \ldots , \overline{U}_{ T }} \sum_{t=1}^{T} \left\| U_{t} - \overline{U}_{t} \right\|_{F}^{2} + \alpha \sum_{t = 1}^{T - 1} \left\| \overline{U}_{t} - \overline{U}_{t + 1} \right\|_{F}^{ 2 }$$`
`$$\overline{U}_{t} \in \left\{ W^{T} : V \in \mathbb {R}^{n \times K} , V^{T} V = I \right\} \forall t$$`

---

### Eigenvector smoothing is nonconvex and solved iteratively

--

.pull-left[

### Eigenvector Smoothing

`$$\overline { U } _ { 1 } ^ { \ell + 1 } = \Pi _ { K } \left( U _ { 1 } + \alpha \overline { U } _ { 2 } ^ { \ell } \right)$$`

`$$\overline { U } _ { t } ^ { \ell + 1 } = \Pi _ { K } \left( \alpha \overline { U } _ { t - 1 } ^ { \ell } + U _ { t } + \alpha \overline { U } _ { t + 1 } ^ { \ell } \right) \\t = 2 , \ldots , T - 1$$`

`$$\overline { U } _ { T } ^ { \ell + 1 } = \Pi _ { K } \left( \alpha \overline { U } _ { T - 1 } ^ { \ell } + U _ { T } \right)$$`

`$$\Pi _ { K } ( M ) = \sum _ { k = 1 } ^ { K } v _ { k } v _ { k } ^ { T }$$`]

--

.pull-right[

### Laplacian Smoothing

`$$\overline { U } _ { 1 } ^ { \ell + 1 } = \Pi _ { K } \left( |L| _ { 1 } + \alpha \overline { U } _ { 2 } ^ { \ell } \right)$$`
`$$\overline { U } _ { t } ^ { \ell + 1 } = \Pi _ { K } \left( \alpha \overline { U } _ { t - 1 } ^ { \ell } + |L| _ { t } + \alpha \overline { U } _ { t + 1 } ^ { \ell } \right)$$`

`$$\overline { U } _ { T } ^ { \ell + 1 } = \Pi _ { K } \left( \alpha \overline { U } _ { T - 1 } ^ { \ell } + |L| _ { T } \right)$$`

Globally solves the following for specific values of `\(\alpha\)`

`$$\min_{ \overline{U}_{1} , \ldots , \overline{U}_{ T }} \sum_{t=1}^{T} \left\| |L|_{t} - \overline{U}_{t} \right\|_{F}^{2} + \alpha \sum_{t = 1}^{T - 1} \left\| \overline{U}_{t} - \overline{U}_{t + 1} \right\|_{F}^{ 2 }$$`

`$$\overline{U}_{t} \in \left\{ W^{T} : V \in \mathbb {R}^{n \times K} , V^{T} V = I \right\} \forall t$$`
]



---


# PiSCES is an extension of Laplacian Smoothing

--

PisCES extends Laplacian smoothing by allowing the number of classes K to be unknown and possibly varying over time.    

--

Here `\(\kappa : \mathbb { R } ^ { n \times n } \mapsto \mathbb { N }\)` is a function that determines the number of eigenvectors to be returned, and `\(V _ { 1 } , \dots , V _ { \kappa } ( M )\)` are the eigenvectors of M corresponding to its `\(\kappa ( M )\)` largest eigenvalues in absolute value.  

--

The iterates for PisCES are heuristic in that no convergence theorems are known

---
# PisCES Application: Rhesus Monkey Genotype

--

Applied to changing gene expression is measured during a broad range of developmental periods in rhesus monkey brains

these are not well estimated by standard methods due to the small sample size of any one developmental period or region of the brain.


---
## Sankey Plots represent the dynamic community structure in PisCES

--

.pull-left[

![](img/Picture3.jpg)
.caption[**Fig. 1:** Sankey plot for prenatal cases]
]

--

.pull-right[

Gray and red boxes denote communities, with height indicating community size. 

Colored “flows” denote groups of genes moving between communities, with height indicating flow size. 

Each flow’s color is determined by its gene membership and equals the mixture of the colors of its input flows. 
]

---
# We can zoom in on further between 2 separate time points

![](img/Picture4.jpg)

---
# Zooming in on Sankey Plots is useful between 2 time periods

![](img/Picture5.jpg)

---

# Simulation: Setup

---

# Modifications to PisCES may be necessary specfic to applications

--

Weighted adjacency matrices over time may be more suitable where fine spatiotemporal changes can be effectively measured

--

Correlation may not be appropriate to to capture coexpressive dependencies over time

--

Other measures of co-expression may be needed where there is insufficient variability to detect correlation between nodes

--

Creation of adjacency matrices can be adhoc (e.g. thresholding) and sensitivity should be assessed to different variants

---

# PiSCES implementations can be accessed online

--

The PiSCES implementation is coded in `Matlab` and freely available at [https://github.com/letitiaLiu/PisCES]()

--

Contains the code to reproduce various graphs in the report

-- 

For applications may be important to compress the time dimension
so that Sankey visualization is feasible

---

# References

Slides created via the R package [**xaringan**](https://github.com/yihui/xaringan)
    </textarea>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function() {
  var d = document, s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})();</script>

<script>
(function() {
  var i, text, code, codes = document.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
})();
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://cdn.bootcss.com/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
